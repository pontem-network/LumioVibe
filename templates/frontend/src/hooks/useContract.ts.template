import { useState, useCallback } from 'react';
import { usePontem } from './usePontem';

// These will be replaced by scaffold script
const CONTRACT_ADDRESS = '{{CONTRACT_ADDRESS}}';
const MODULE_NAME = '{{MODULE_NAME}}';
const LUMIO_RPC = 'https://api.testnet.lumio.io/v1';

export function useContract() {
  const { pontem, connected, account } = usePontem();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  /**
   * Call an entry function (modifies blockchain state)
   * All arguments MUST be strings - Pontem requires this format
   */
  const callEntryFunction = useCallback(async (
    functionName: string,
    args: (string | number)[] = [],
    typeArgs: string[] = []
  ) => {
    if (!pontem || !connected) {
      setError('Wallet not connected');
      return null;
    }

    setLoading(true);
    setError(null);

    try {
      // Verify network before transaction
      const network = await pontem.network();
      if (!network.api?.includes('lumio')) {
        throw new Error('Please switch to Lumio Testnet in Pontem Wallet');
      }

      // IMPORTANT: All arguments must be strings for Pontem
      const { success, result } = await pontem.signAndSubmit({
        function: `${CONTRACT_ADDRESS}::${MODULE_NAME}::${functionName}`,
        arguments: args.map(a => String(a)),
        type_arguments: typeArgs,
      });

      if (!success) {
        throw new Error('Transaction was rejected');
      }

      return result;
    } catch (e) {
      const msg = e instanceof Error ? e.message : 'Transaction failed';
      setError(msg);
      return null;
    } finally {
      setLoading(false);
    }
  }, [pontem, connected]);

  /**
   * Call a view function (read-only, doesn't require wallet)
   */
  const callViewFunction = useCallback(async <T>(
    functionName: string,
    args: (string | number)[] = [],
    typeArgs: string[] = []
  ): Promise<T | null> => {
    setError(null);

    try {
      const response = await fetch(`${LUMIO_RPC}/view`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          function: `${CONTRACT_ADDRESS}::${MODULE_NAME}::${functionName}`,
          type_arguments: typeArgs,
          arguments: args.map(a => String(a)),
        }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`View call failed: ${errorText}`);
      }

      const result = await response.json();
      return result[0] as T;
    } catch (e) {
      const msg = e instanceof Error ? e.message : 'View call failed';
      setError(msg);
      return null;
    }
  }, []);

  // ============================================================
  // Contract-specific functions (customize these for your contract)
  // ============================================================

  /**
   * Initialize the contract for the connected account
   */
  const initialize = useCallback(() => {
    return callEntryFunction('initialize');
  }, [callEntryFunction]);

  /**
   * Increment the counter by 1
   */
  const increment = useCallback(() => {
    return callEntryFunction('increment');
  }, [callEntryFunction]);

  /**
   * Get the current count for an address
   */
  const getCount = useCallback((address: string) => {
    return callViewFunction<number>('get_value', [address]);
  }, [callViewFunction]);

  /**
   * Check if address has initialized
   */
  const isInitialized = useCallback((address: string) => {
    return callViewFunction<boolean>('exists_at', [address]);
  }, [callViewFunction]);

  const clearError = useCallback(() => setError(null), []);

  return {
    // Contract functions
    initialize,
    increment,
    getCount,
    isInitialized,
    // Generic callers for custom functions
    callEntryFunction,
    callViewFunction,
    // State
    loading,
    error,
    clearError,
    account,
    // Contract info
    contractAddress: CONTRACT_ADDRESS,
    moduleName: MODULE_NAME,
  };
}
