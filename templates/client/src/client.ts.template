import {
  Aptos,
  AptosConfig,
  Network,
  Account,
  Ed25519PrivateKey,
  InputGenerateTransactionPayloadData,
  CommittedTransactionResponse,
} from '@aptos-labs/ts-sdk';

const LUMIO_TESTNET_CONFIG = {
  fullnode: 'https://api.testnet.lumio.io/v1',
  indexer: 'https://indexer.testnet.lumio.io/v1/graphql',
  faucet: 'https://faucet.testnet.lumio.io',
};

export interface {{CLIENT_CLASS_NAME}}Config {
  contractAddress: string;
  privateKey?: string;
}

export class {{CLIENT_CLASS_NAME}} {
  private aptos: Aptos;
  private contractAddress: string;
  private account?: Account;

  constructor(config: {{CLIENT_CLASS_NAME}}Config) {
    const aptosConfig = new AptosConfig({
      network: Network.CUSTOM,
      fullnode: LUMIO_TESTNET_CONFIG.fullnode,
      indexer: LUMIO_TESTNET_CONFIG.indexer,
      faucet: LUMIO_TESTNET_CONFIG.faucet,
    });

    this.aptos = new Aptos(aptosConfig);
    this.contractAddress = config.contractAddress;

    if (config.privateKey) {
      const privateKey = new Ed25519PrivateKey(config.privateKey);
      this.account = Account.fromPrivateKey({ privateKey });
    }
  }

  get client(): Aptos {
    return this.aptos;
  }

  get address(): string {
    return this.contractAddress;
  }

  get signer(): Account | undefined {
    return this.account;
  }

  // ============================================
  // ENTRY FUNCTIONS
  // ============================================

  async initialize(): Promise<CommittedTransactionResponse> {
    if (!this.account) {
      throw new Error('No account configured. Provide privateKey in config.');
    }

    const payload: InputGenerateTransactionPayloadData = {
      function: `${this.contractAddress}::{{MODULE_NAME}}::initialize`,
      functionArguments: [],
    };

    const transaction = await this.aptos.transaction.build.simple({
      sender: this.account.accountAddress,
      data: payload,
    });

    const pendingTx = await this.aptos.signAndSubmitTransaction({
      signer: this.account,
      transaction,
    });

    return await this.aptos.waitForTransaction({
      transactionHash: pendingTx.hash,
    });
  }

  // ============================================
  // VIEW FUNCTIONS
  // ============================================

  async getOwner(account: string): Promise<string> {
    const result = await this.aptos.view({
      payload: {
        function: `${this.contractAddress}::{{MODULE_NAME}}::get_owner`,
        functionArguments: [account],
      },
    });
    return result[0] as string;
  }

  async getCreatedAt(account: string): Promise<number> {
    const result = await this.aptos.view({
      payload: {
        function: `${this.contractAddress}::{{MODULE_NAME}}::get_created_at`,
        functionArguments: [account],
      },
    });
    return Number(result[0]);
  }

  async isInitialized(account: string): Promise<boolean> {
    const result = await this.aptos.view({
      payload: {
        function: `${this.contractAddress}::{{MODULE_NAME}}::is_initialized`,
        functionArguments: [account],
      },
    });
    return result[0] as boolean;
  }

  // ============================================
  // UTILITY FUNCTIONS
  // ============================================

  async fundAccount(address: string, amount: number = 100_000_000): Promise<void> {
    await this.aptos.fundAccount({
      accountAddress: address,
      amount,
    });
  }

  async getBalance(address: string): Promise<number> {
    const resources = await this.aptos.getAccountResources({
      accountAddress: address,
    });

    const coinResource = resources.find(
      (r) => r.type === '0x1::coin::CoinStore<0x1::lumio_coin::LumioCoin>'
    );

    if (!coinResource) {
      return 0;
    }

    return Number((coinResource.data as { coin: { value: string } }).coin.value);
  }
}
